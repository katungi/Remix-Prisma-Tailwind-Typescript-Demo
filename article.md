# Get started with remix

Remix is an amazing new framework created by the team behind react router.
Remix is a fresh take on the Full-stack web-framework arena.

## Setup

### Setup Remix

To get started, run the following command:

``` bash
npx create-remix@latest
```

To follow along, in the terminal menu prompt that is generated by the command,
choose `Just the basics`, for language choose `Typescript`, and for our server, we will go with `Express Server`.

```bash
IMAGE GOES HHERE  !!!
```

Once that is done, you will have a working remix web app. Let's spin it and see if it works by running:

```bash
npm run dev
```

All done. Now go to your browser and go to `http://localhost:3000/` and you should see something like this:

### Setup Prisma

In this tutorial, we will need to interact with our database. We will use Prisma as our ORM to abstract process for us.

To install prisma, first `cd` into the project folder, and run the following command:

```bash
npm install prisma typescript ts-node @types/node --save-dev
```

This command will install a couple of things. It will install `typescript` into our project, it will install Prisma and finally it will install type definitions for Node.js.

Next step is to install the prisma client and setup our db. To do that, run the following command:

```bash
npm i @prisma/client@latest
```

For ease of use, we will use sqlite as our database. Prisma however allows you to use `Postgres`, `MySQL`, `MongoDB`, `CockroachDB` and other databases.

To setup our db, let's run this quick command to initialize prisma into our project. The command will also set `sqlite` as the default database.

```bash
npx prisma init --datasource-provider sqlite
```

With that, go to the prisma folder, in the `schema.prisma` file and check out the results. We are now good to go!

### Setup Tailwind

To build a beautiful yet simple UI, we will employ tailwind CSS. But hey, feel free to use whichever you want.

To install Tailwind run:

```bash
npm install -D tailwindcss postcss autoprefixer concurrently
```

That command will install a couple of packages used to post-compile tailwind.

Next, we will run the following command to initialize tailwind in the project, create `tailwind` and `postcss` config files.

```bash
npx tailwind init -p
```

In your root folder, you should see 2 files created, `tailwind.config.js` and `postcss.config.js`

Next, Let's add the files to our template files to our tailwind config. Change the lines below:

```js
...
  content: [
    "./app/**/*.{js,ts,jsx,tsx}",
  ],
...
```

Next, we will edit our package.json scripts to compile our tailwind code during the build process.

In your `package.json` edit this:

```json
 "scripts": {
    "build": "npm run build:css && remix build",
    "build:css": "tailwindcss -m -i ./styles/app.css -o app/styles/app.css",
    "dev": "remix build && run-p dev:*",
    "dev:node": "cross-env NODE_ENV=development nodemon ./build/index.js --watch ./build/index.js",
    "dev:remix": "remix watch",
    "dev:css": "tailwindcss -w -i ./styles/app.css -o app/styles/app.css",
    "postinstall": "remix setup node",
    "start": "cross-env NODE_ENV=production node ./build/index.js"
  }
``

Next, add the tailwind directives to your css. Create a css file and add the following. I prefer creating a seperate folder for my css.

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

Finally, import your css file into the root file at `./app/root.jsx`

```jsx
import styles from "./styles/app.css"

export function links() {
  return [{ rel: "stylesheet", href: styles }]
}
```

Now we are all set!

## Modelling Our data

In this demo, we will create a simple website where a user can:

- Add an album using a form
- Click on the album and get a view with all songs in the album.

We therefore need 2 Models with a one to many relationship.

To define our relationships, let's jump into the `schema.prisma` file in the prisma folder!

First, we will create an `Album` model that will have a unique name and id (which auto-increments), an image and an array of `songs`.

```js
model Album {
  id    Int    @id @default(autoincrement())
  name  String @unique
  image String
  songs Song[]
}
```

Next, we will create a `Songs` model that will have an id (which auto-increments), a name, an image url, and an album to which it belongs to.

```js
model Song {
  id      Int      @id @default(autoincrement())
  name   String @unique
  image   String
  albumId Int
  album   Album    @relation(fields: [albumId], references: [id])
}
```

After creating our models we will run to deploy our changes to the db:

```bash
npx prisma migrate dev --name first_migration
```

Boom, we have our db setup. Let's get our hands dirty.

## Diving into Remix! ðŸš€

To get started, let's dive into the `./app/routes/index.tsx`. This will be the route page for our website. In this `routes` folder, we can declare routes to other pages.

For example crearing an `albums` folder and an `index.tsx` will create a route `/albums`.

Let's add a simple landing page for out website. In our `routes/index.tsx`

```jsx
export default function Index() {
  return (
    <div className='flex flex-col items-center justify-center min-h-screen py-2'>
      <main className='flex flex-col items-center justify-center w-full flex-1 px-20 text-center'>
        <h1 className='text-2xl xs:text-3xl md:text-6xl font-bold'>
          Welcome to{' '}
          <a className='text-green-600'>
            Music Box
          </a>
        </h1>
      </main>
    </div>
  );
}
```

Next, let's display some data. Since we don't have a way to add data to our db, we will use `prisma studio`. To use it run:

```bash
npx prisma studio
```

Now go to `http://localhost:5555` and have fun feeding in data to the tables.

Assuming you have some data, we can now fetch our albums and display them!

### Data Loading in Remix

A cool thing about Remix is that data loading is well in-built into the framework.

How this works is that the react component in the route, is it's own API route. It has the capability to talk to your server itself. Cool right?

This is awesome because you don't have to fetch data to an endpoint because the page itself, is an endpoint. Let's see this in practice.

Let's create a function that will be called when we need to fetch data. let's call it `loader`. In the function, we will:

- Create a prisma Client to connect to prisma
- Query all albums in the db and return the data
- close our prisma client.

The code will looks like this:

```jsx
export async function loader() {
  const prisma = new PrismaClient();
  const allAlbums = await prisma.album.findMany();
  console.log(allAlbums);
  await prisma.$disconnect();
  return allAlbums;
}
```

The loader function should be outside your outside your main `index` function. To access the data we returned in the function, we import the data using `useLoader()` exported from `Remix`.

Loaders act like the API's, they will fetch the data, and hydrate the index component. N

Now, let's get our data. Within the `index` function (UI component), before the return statement create a variable to get the data from the loader.

```jsx
const albums = useLoaderData();
```

We can now loop over the data and display it. So now inside the Ui component, Right below our title. add this code:

```jsx
        <div className='mt-4 grid grid-cols-1 xs:grid-cols-3 md:grid-cols-4 xl:grid-cols-4 gap-4'>
          {albums.map((item: any) => (
            <div className='bg-gray-900 shadow-lg rounded p-3' key={item.id}>
              <div className='group relative'>
                <img className='w-full h-full md:w-72 block rounded' src={item.image} alt='not found' />
              </div>
              <div className='p-5'>
                <h3 className='text-white text-lg'>{item.name}</h3>
              </div>
            </div>
          ))}
        </div>
```

### Adding Data to DB

We need to add data into our db. Let's create a form to add data.

We will import `Form` tag exported from the `remix` library. We have to specify the `http method` we want our form to use when submitted. We will use `Post` to send data to the db.

We will then add the form components.

```jsx
      <Form method='post' className="bg-white shadow-lg rounded px-12 pt-6 pb-8 mb-4">
          <div className="mb-4">
            <input className="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" name='name' placeholder="Name" size={30} />
          </div>
          <div className='mb-4'>
            <input className="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" name='image' placeholder="Album Art" size={30} />
          </div>
          <button className='rounded-lg border-2 border-solid border-green-600 p-5 text-center text-green-600 mt-10' type="submit" disabled={busy}>
            {busy ? "creating..." : "creating New Album"}
          </button>
        </Form>
```

Your suspicion is right, Remix forms work almost the same as native HTML forms, with some sugar on top.

We used the `busy` key word. In remix, you can track the pending navigation of the web-app, by using the `useTransition` hook.

Outside the return statement, create an if statement to check if the app is pending a navigation caused by submitting the form. We do that like this:

```jsx
  const { state } = useTransition();
  const busy = state === "submitting";
```

So when the state of the component is `submitting`, we can track store that state and use it in our app like we did in the button.

To now submit the data, we need an `action` function, that will be called by the form to submit the data. Now outside of the UI component, have this:

```jsx
export async function action({ request }) {
  const form = await request.formData();
  const prisma = new PrismaClient();
  const allAlbums = await prisma.album.create({
    data: { name: form.get('name'), image: form.get('image') },
  });
  console.log(allAlbums);
  await prisma.$disconnect();
  return true;
}

```

Notice how easy it is to have access to our form values by name using the syntax `form.get()`.

Now filling in your form should create a new album ðŸš€

You'll be able see the new album immediately without refreshing your browser because, the UI is hydrated with the data immediately.

### Dynamic Routing in Remix